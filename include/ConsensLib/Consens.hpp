#pragma once

#include <limits>

#include "GraphTraits.hpp"
#include "Types.hpp"
#include "Intern/Enumeration.hpp"

namespace ConsensLib {

/**
 * @brief Perform the CONSENS algorithm to enumerate all node sets that form connected subgraphs
 *        of a given input graph with optional specifications of an upper bound
 *        for the number of nodes contained and additional filter criteria
 *
 * @tparam Graph Type of graph for enumeration.
 * @tparam Node Type of node contained in the graph.
 * @tparam FilterFunc Type of filter for the option of filtering the generated node sets.
 * @tparam Compare Type of compare function that defines a strict total ordering in the nodes.
 *
 * @param graph Input graph
 * @param upper Optional upper bound for the size of the subgraphs.
 * @param filter Optional filter criteria applied to the subgraphs.
 *               Must accept std::vector<Node> as input and return a boolean.
 *               See \ref ConsensLib::NoFilter as an example.
 * @param compare Compare function defining a strict total ordering on the nodes of the graph.
 *                By default std::less is used
 *
 * The CONSENS algorithm uniquely enumerates all sets of nodes that form a
 * connected induced subgraph of a given query graph. The subgraphs are generated by recursively
 * adding neighbors to a currently considered subgraph. Additionally a set of forbidden nodes
 * is considered for each subgraph and duplicate generation is avoided by not adding neighbors
 * to existing subgraphs that are forbidden.
 *
 * A traits struct with static member functions must be defined for the graph type 'Graph'
 * which needs:
 *
 * 'Node' which is a typedef, class or struct for the type of node.
 *
 * 'adjancencyBegin' which is static, takes a node and the graph as arguments
 * and returns an iterator pointing to the begin of the adjacency list of the node.
 *
 * 'adjancencyEnd' which is static, takes a node and the graph as arguments
 * and returns an iterator pointing to the end of the adjacency list of the node.
 *
 * 'nodesBegin' which is static, takes a graph as argument
 * and returns an iterator pointing to the begin of the list of nodes.
 *
 * 'nodesEnd' which is static takes a graph as argument
 * and returns an iterator pointing to the end of the list of nodes.
 *
 * 'listsSorted' which is static, takes no arguments
 * and returns true if all adjacency lists are sorted.
 *
 * If all adjacency lists are sorted it is possible to apply set operations such as 'union',
 * 'intersection' and 'difference' in asymptotic linear time with respect to the number of
 * nodes contained in the query graph. When the adjacency lists are not sorted this is not possible
 * and the asymptotic runtime of one recursive call is O(n log n)
 * where n is the number of nodes contained in the query graph.
 */
template<typename Graph,
         typename Node = typename GraphTraits<Graph>::Node,
         typename FilterFunc = NoFilter,
         typename Compare = std::less<Node>>
std::vector<std::vector<Node>> runConsens(
    const Graph& graph,
    size_t upper = std::numeric_limits<size_t>::max(),
    const FilterFunc& filter = FilterFunc(),
    const Compare& compare = Compare())
{
  return Intern::runEnumeration<Graph, Node, FilterFunc, Compare>(graph, upper, filter, compare);
}
} // end namespace ConsensLib
